
## zkProver

The task of creating the execution trace is performed by a component called the **zkExecutor**.
The zkExecutor takes as inputs the transactions of a batch, a ChainID, the root of a Merkle tree representing the previous state of the zkEVM in that chain, and
the root of the new state after executing the transactions. 
Additionally, the zkExecutor gets values 
of the current state of the zkEVM to build the proof.

The zkExecutor is, in fact, an interpreter of an assembly language called zkASM. The zkASM language is used to build a program called zkROM which when executed by the zkExecutor, provides a suitable execution trace. The zkROM
is produced from the zkASM language by using the zkASM compiler, which is located in the this repository:
[zkASM Compiler](https://github.com/0xPolygonHermez/zkasmcom). 
In the zkROM program (located in the this repository: 
[zkROM](https://github.com/0xPolygonHermez/zkevm-rom)),
each EVM opcode is implemented with a set of zkASM instructions. Each instruction utilizes a row of the execution trace matrix, also known as a "step" of the zkEVM. 

*Note*: A complete description of the zkASM language can be found in the following section [Introduction to zkASM](../zkASM/introduction.md).

To see the zkASM compiler in action, it is possible to compile a .zkasm into the corresponding .json file using the following commands inside the previous
repository:

```sh
$ node src/zkasm.js <input.zkasm> -o <output.json>
```

*Note*: It is important to install the node modules. 
```sh
$ npm install
```
and build the parsers.
```sh
$ npm run build
```

The .json file contains a field `program` which is an array of maps with each element representing a line of the .zkasm file. Among other fields, every element contains: 

- `fileName`: Absolute path of the file containing the corresponding assembly row.
- `lineStr`: String representing the complete line of the corresponding .zkasm file.
- `line`: A line identifier. 
Moreover, the corresponding setters, selectors, constants, and instructions will be assigned accordingly. This point will be important for PIL validations (described below). 


The zkExecutor is a part of the **zkProver**, which is the
core component of the Polygon zkEVM.

![](./figures/big-picture.png)

<div align="center"><b> Figure 1: Detailed Diagram of the Prover in Polygon zkEVM </b></div>

<br>
At the same time, there exists the need to check the correctness of each transition between the rows of the execution trace generated by the zkExecutor. To do so, a new Polynomial Identity Language **PIL** has been created.

Recall that having an execution trace is equivalent to having polynomials, each one representing one column. Therefore, using this language we will be able to express several relations between consecutive rows of each of the columns computed by the zkExecutor in a polynomial-like way, allowing us to prove the correct execution via a STARK Recursion. The .pil files are compiled via a PIL compiler, which is located in the following repository: [PIL Compiler](https://github.com/0xPolygonHermez/pilcom).
The compiler, as in the zkASM case, produces a .json which will be interpreted by the STARK generator and together with the execution trace (seen as a set of polynomial evaluations) generated by the zkExecutor, will produce a proof. 

*Note*: A complete description of the PIL language can be found in the section: [Introduction to PIL](../PIL/introduction.md).

To see the PIL compiler in action, it is possible to compile a .pil in the corresponding .json file using the following commands inside the above-mentioned repository:

```sh
$ node src/pil.js <input.pil> -o <output.pil.json>
```

*Note*: It is important to install the node modules. 
```sh
$ npm install
```
and build the parsers.
```sh
$ npm run build
```

The .json file specifies, under the `references` key, all the polynomials that have references in the .pil file. The `references` key-value stores, in its keys, the name and the namespace associated with each polynomial in the form `nameSpace.name`. Each value describes a property associated with each polynomial:

- `type`: Specifies if a certain polynomial is *committed*, *constant*, *calculated*, and so on.

- `id`: uUnique *id* associated with each polynomial.

- `polDeg`: Reflects the resulting polynomial degree.

- `isArray`: Flag to control array-based polynomial definitions. 
(See [PIL Components](../PIL/components.md) for more information.)

Among all the contents of the .json file, there is a key called `expressions` which is an array containing all the identities and operations among the corresponding
polynomials defined by the zkExecutor. The used values are input freely from the executor or taken from the .json compiled by the zkASM compiler. Moreover, there exist other keys which represent all the inclusion, permutation and copy constrain arguments. This .json will be finally used in the STARK proof generation, which will prove the specified constraints. 

Other important key fields for the debugging process are:

- `nCommitements`: Specifies the total number of committed polynomials.
 
- `nConstants`: Specifies the total number of constant polynomials referenced in the PIL file. 
